// ARCHIVO: alu.v
// Harris version con soporte para punto flotante IEEE 754 - 32 bits
// Implementación modular para FADD y FMUL.

module alu(
    input  [31:0] a, b,
    input  [3:0] ALUControl,
    output reg [31:0] Result,
    output reg [31:0] ResultHi,
    output wire [3:0] ALUFlags,
    input wire [31:0] ExtImm,
    input wire [31:0] A
);

    wire neg, zero, carry, overflow;
    wire [31:0] condinvb;
    wire [32:0] sum;
    wire is_logic;

    // Lógica para multiplicación de enteros (sin cambios)
    wire signo_a = a[31];
    wire signo_b = b[31];
    wire resultado_signo = signo_a ^ signo_b;
    wire [31:0] abs_a = signo_a ? (~a + 1) : a;
    wire [31:0] abs_b = signo_b ? (~b + 1) : b;
    wire [63:0] mul_unsigned = abs_a * abs_b;
    wire [63:0] smul_result = resultado_signo ? (~mul_unsigned + 1) : mul_unsigned;
    wire [63:0] umul_result = a * b;

    // Salidas de los módulos de punto flotante
    wire [31:0] float_add_result;
    wire [31:0] float_mul_result;

    // Instancia del módulo FADD
    fadd fadd_inst (
        .a(a),
        .b(b),
        .result(float_add_result)
    );

    // Instancia del módulo FMUL
    fmul fmul_inst (
        .a(a),
        .b(b),
        .result(float_mul_result)
    );
    
    assign condinvb = ALUControl[0] ? [cite_start]~b : b; [cite: 7]
    [cite_start]assign sum = a + condinvb + ALUControl[0]; [cite: 8]
    
    always @(*) begin
        [cite_start]Result   = 32'b0; [cite: 24]
        [cite_start]ResultHi = 32'b0; [cite: 24]
        [cite_start]case (ALUControl[3:0]) [cite: 25]
            [cite_start]4'b0000, 4'b0001: Result = sum; [cite: 25] [cite_start]// ADD, SUB [cite: 26]
            [cite_start]4'b0010:          Result = a & b; [cite: 26] [cite_start]// AND [cite: 27]
            [cite_start]4'b0011:          Result = a | b; [cite: 27, 28]     [cite_start]// OR [cite: 28]
            [cite_start]4'b0111:          Result = a * b; [cite: 28] [cite_start]// MUL [cite: 29]
            [cite_start]4'b0100:          Result = a / b; [cite: 29] [cite_start]// DIV [cite: 30]
            [cite_start]4'b1011: Result = ExtImm; [cite: 30] [cite_start]// MOV low16 [cite: 31]
            4'b1100: Result = (A & 32'h000FFFFF) | [cite_start]ExtImm; [cite: 31, 32]   [cite_start]// MOVT high16 [cite: 32]
            4'b1101: Result = (A & 32'hFF000FFF) | [cite_start]ExtImm; [cite: 32, 33]   [cite_start]// MOVM  [cite: 33]

            4'b0110:          begin               // SMUL
                [cite_start]Result = smul_result[31:0]; [cite: 33]
                [cite_start]ResultHi = smul_result[63:32]; [cite: 34]
            end
            4'b0101:          begin               // UMUL
                [cite_start]Result = umul_result [31:0]; [cite: 35]
                [cite_start]ResultHi = umul_result [63:32]; [cite: 35]
            end
            4'b1000:          begin               // FADDS (suma flotante)
                [cite_start]Result = float_add_result; [cite: 35]
            [cite_start]end [cite: 36]
            4'b1001:          begin               // FMULS (multiplicación flotante)
                [cite_start]Result = float_mul_result; [cite: 36]
            [cite_start]end [cite: 37]
            [cite_start]default:          Result = 32'b0; [cite: 37]
        [cite_start]endcase [cite: 38]
    end

    [cite_start]assign neg = Result[31]; [cite: 38]
    [cite_start]assign zero = (Result == 32'b0); [cite: 38]

    [cite_start]assign is_logic = (ALUControl[3:1] == 3'b001)   // AND, OR 
                    || [cite_start](ALUControl == 4'b0100)      // DIV 
                    || [cite_start](ALUControl == 4'b0111)      // MUL 
                    || [cite_start](ALUControl == 4'b0110)      // SMUL 
                    || [cite_start](ALUControl == 4'b0101)      // UMUL 
                    || [cite_start](ALUControl == 4'b1000)      // FADDS 
                    || [cite_start](ALUControl == 4'b1001)      // FMULS 
                    || (ALUControl == 4'b1010);     // MOV

    assign carry = is_logic ? 1'b0 : sum[32]; 
    assign overflow = is_logic ? 1'b0 :
        ~(a[31] ^ b[31] ^ ALUControl[0]) &&
        (a[31] ^ sum[31]); 
    assign ALUFlags = {neg, zero, carry, overflow};

endmodule